#+TITLE: ga-image Project Plan
#+AUTHOR: J. Bromley <jbromley@gmail.com>
#+DATE: February 23, 2011

* ga-image application						    :PROJECT:
** Why?
 - Write a more complicated (than ga-circles) genetic algorithm application
 - Experiment with structured genomes and the corresponding GA operators
 - Produce an interesting movie out of the evolution
 - Gain experience with doing visualizations in Common Lisp
 - Compare performance to algorithm from [[http://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/][Genetic Programming:
   Evolution of Mona Lisa]]
 - Experiment with use of OpenCV and cl-opencv

** Outcome
An application that allows the user to either specify an image or snap
an image from the video camera. The application will then use a
genetic algorithm to copy the source image. As the evolution continues
the best individual from each generation will be shown in the main
window. If the user desires, a movie of the evolution can also be
written to disk. The evolution continues until either the fitness hits
a plateau or the user manually ends evolution. The final image is then
written to disk with some metrics about its fitness.

** Brainstorming Ideas
*** show target image and best individual side-by-side
*** use opticl or ch-image for drawing
*** use cl-cairo2 for drawing
*** point struct to handle points
*** polygon struct to handle polygons as a number of points
*** run function has single optional file name parameter
*** if there is no file name parameter then capture an image from camera
*** camera capture show on target image half of window
*** snap image from webcam with space bar
*** build GUI with SDL or with OpenCV
*** mutation - add or subtract a small number from target
*** mutation - give each component a possibility of being mutated
*** if number of sides is mutated, add or remove points
*** represent polygons as number of sides and a list of vertices
Use absolute x, y coordinates
*** represent polygons as number of sides, origin, and a list of vertices
**** Use polar coordinates w/ respect to shape origin
**** mutate by tweaking angles and radii
*** crossover by switching polygons between parents
*** have a termination condition
*** allow manual termination
*** write a move of the evolution
*** allow number of polygons as program argument
*** allow maximum number of polygon sides as a program argument
*** how do we handle fixing up genomes after crossover/mutation

** Plan
*** Drawing and data structure basics
**** DONE create point and polygon structs
The default point is the origin. The default polygon has zero sides
and no color, i.e. ARGB = (0, 0, 0, 0).
**** DONE create functions for random points and random polygons
The =random-point= function creates a point in the region defined by
(0, 0) and (=*image-width*=, =*image-width*=). Random polygons have
from three to =*max-sides*= sides and have an optional maximum alpha
parameter. 

Currently there are two random polygon functions. One simply selects
all points within the image area. The second selects a random size
smaller than the image's smallest dimension, selects points in a
square of this size and then randomly places the polygon such that it
is guaranteed to be completely within the image.
**** DONE decide on which polygon function works best
It turns out I didn't really need to do this. The original reason I
did this was that I thought I would generate the starting population
using these functions. However, it became apparent that I should just
generate random bit strings and use those for my initial population.
**** DONE create function for random colors
I am using the cl-colors package to handle colors. This works well
with cl-cairo2.
**** DONE test program to draw random polygons with cairo
**** DONE figure out how to convert between surface types (memory to screen)
 1. Create an image (in-memory) surface with desired dimensions.
 2. Create a context to draw on the image surface.
 3. Draw on the image surface.
 4. Destroy the image context.
 5. Create an xlib context.
 6. Use set-source-surface to set the image surface as the source.
 7. Call paint on the xlib context.
**** DONE read a reference image into a surface
The `load-png` function loads a PNG image into a surface. In the
future this should be expanded to load standard image types.
**** DONE render a genotype onto a surface
The `render-genome-to-surface` draws a genome onto a surface. The
`render-genome-to-window` renders the genome to a visible window and
then returns the context for the window.
**** TODO test program for putting Cairo bits into OpenCV
**** TODO implement OpenCV functions for image differencing
*** Representation and operators
**** DONE experiment with Cartesian and polar representations
**** TODO calculate the difference between any image and the reference image
**** DONE design the chromosomes
Originally, I had thought of directly using the polygon and point
structs and then writing special genetic operators for this
representation. However, I have not found much information on whether
such a representation will work and what the genetic operators would
look like.

The standard bit-string chromsome might look like the following.

#+BEGIN_SRC javascript
{ polygons: [{
    sides: 4,
    vertices: [{x_0: 10, y_0: 10}, ..., {x_15: 10, y_15: 10}],
    color: {alpha: 8, red: 8, green: 8, blue: 8}
  }]
}
#+END_SRC

If a polygon can have from three to 18 sides (4 bits) then a polygon
will have 396 bits (50 bytes). A complete chromosome with 64 polygons
would then have 21504 bits (3168 bytes). A population of 64
chromosomes would then require 202,752 bytes.

If we limit a polygon to have from three to ten sides (3 bits), then a
polygon will have 235 bits (30 bytes). For 64 polygons, this gives us
a chromosome with 15040 bits (1880 bytes). A population of 64
chromosomes would require 120320 bytes.
**** TODO calculate schemata for binary bit string vs integer representation
This task will allow me to know is an integer representation has
enough information (i.e. schemata) to efficiently do GA.
**** TODO design crossover operator
**** TODO design mutation operator
*** Frameworks
**** DONE function to create the initial population
I just use random bit strings for the initial population and the
decoder handles making sense of these bit strings.
**** TODO function for rank selection
**** TODO function to drive evolution
**** TODO modify framework from ga-circles for new type of genome
